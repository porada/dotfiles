#!/bin/sh

# Enable strict mode
set -eu

# Ensure the library is sourced only once
if [ -n "${DOTFILES_BIN_DIR-}" ]; then
  echo '`dotlib` is already defined' >&2
  exit 1
fi

# Resolve common paths
DOTFILES_BIN_DIR="$(dirname "$(realpath "$0")")"
DOTFILES="$(dirname "$DOTFILES_BIN_DIR")"

# Resolve config paths
DOTFILES_CONFIG_DIR="$DOTFILES/.config"
# shellcheck disable=SC2034
DOTFILES_FISH_CONFIG_DIR="$DOTFILES_CONFIG_DIR/fish"
# shellcheck disable=SC2034
DOTFILES_NPM_CONFIG_DIR="$DOTFILES_CONFIG_DIR/npm"

# Define helper variables and functions
DOTFILES_DEFAULT_IFS="$IFS"
DOTFILES_SSH_KEY="$HOME/.ssh/id_ed25519"

__() {
  if [ $# -eq 0 ]; then
    __print_error_and_exit '`__` requires at least one argument'
  fi

  if [ "$1" = 'brew' ]; then
    __print_command "$@"
    shift
    brew "$@"
  else
    __print_command "$@"
    command "$@"
  fi
}

__chmod() {
  if [ -d "$1" ]; then
    __ chmod 700 "$1"
  elif [ -f "$1" ]; then
    __ chmod 600 "$1"
  fi
}

__dotfiles() {
  if [ $# -eq 0 ]; then
    __print_error_and_exit '`__dotfiles` requires at least one argument'
  fi

  command="$1"
  shift

  "$DOTFILES_BIN_DIR/dotfiles-$command" "$@"
}

__dotfiles_bin() {
  if [ $# -eq 0 ]; then
    __print_error_and_exit '`__dotfiles_bin` requires at least one argument'
  fi

  command="$1"
  shift

  "$DOTFILES_BIN_DIR/$command" "$@"
}

__dotfiles_cd_bin() {
  cd "$DOTFILES_BIN_DIR" \
    || __print_error_and_exit "Could not change directory to \`$DOTFILES_BIN_DIR\`"
}

__dotfiles_cd_root() {
  cd "$DOTFILES" \
    || __print_error_and_exit "Could not change directory to \`$DOTFILES\`"
}

__dotfiles_exec() {
  if [ $# -eq 0 ]; then
    __print_error_and_exit '`__dotfiles_exec` requires at least one argument'
  fi

  command="$1"
  shift

  if [ "${1-}" = '--print' ]; then
    shift
    __print_command dotfiles "$command" "$@"
  fi

  exec "$DOTFILES_BIN_DIR/dotfiles-$command" "$@"
}

__dotfiles_is_callable() {
  [ -x "$DOTFILES_BIN_DIR/dotfiles-$1" ]
}

__dotfiles_is_clean() {
  __ git -C "$DOTFILES" diff --quiet && __ git -C "$DOTFILES" diff --cached --quiet
}

__dotfiles_ls_bin() {
  if [ $# -gt 0 ]; then
    pattern="$1"
  else
    pattern='*'
  fi

  (
    __dotfiles_cd_bin
    find . -maxdepth 1 -type f -name "$pattern" -perm -u+x -exec basename {} \; \
      | sort \
      | xargs ls
  )
}

__dotfiles_revision() {
  git -C "$DOTFILES" rev-parse --short HEAD
}

__find() {
  if [ $# -ne 2 ]; then
    __print_error_and_exit '`__find` requires two arguments'
  fi

  files="$(find "$1" -maxdepth 1 -name "$2" -type f -print | sort)"

  if [ -n "$files" ]; then
    printf '%s\n' "$files"
  else
    printf ''
  fi
}

__git_default_commit_count() {
  default=10
  count=0

  if git rev-parse --verify HEAD > /dev/null 2>&1; then
    count=$(git rev-list --count HEAD)
  fi

  if [ "${1-}" = '--no-initial' ] && [ "$count" -gt 0 ]; then
    count=$((count - 1))
  fi

  echo $((count < default ? count : default))
}

__git_default_log_params() {
  params="--date=format:'%Y-%m-%d / %H:%M' --pretty=format:'%C(dim)%h"
  [ "${1-}" != "--no-refs" ] && params="$params%C(reset)%C(red)%d"
  params="$params %C(reset)%s %C(dim)%cd / %an%C(reset)'"

  echo "$params"
}

__git_diff_excluded_files() {
  if [ "${1-}" = '--related' ]; then
    echo 'package.json'
  fi

  echo 'package-lock.json'
  echo 'pnpm-lock.yaml'
  echo 'yarn.lock'
}

__git_is_commit_reference() {
  if git rev-parse --verify "$1" > /dev/null 2>&1; then
    return 0
  else
    return 1
  fi
}

__git_is_file_in_commit() {
  if [ $# -ne 2 ]; then
    __print_error_and_exit '`__git_is_file_in_commit` requires two arguments'
  fi

  if git diff-tree --no-commit-id --name-only -r "$1" | grep -q "$2"; then
    return 0
  else
    return 1
  fi
}

__ifs_restore() {
  IFS="$DOTFILES_DEFAULT_IFS"
}

__ifs_set() {
  if [ "$IFS" != "$DOTFILES_DEFAULT_IFS" ]; then
    __print_error_and_exit '`IFS` is already being overridden'
  fi

  if [ $# -eq 1 ]; then
    IFS="$1"
  else
    IFS='
'
  fi
}

__is_brew_installed() {
  if [ $# -eq 0 ]; then
    brew --version > /dev/null 2>&1
  else
    brew list --formula | grep -q "^$1\$" > /dev/null 2>&1
  fi
}

__is_brew_keg_only() {
  brew info "$1" --json=v2 2> /dev/null | grep -q '"keg_only": true'
}

__is_callable() {
  sh -c "command -v \"$1\"" > /dev/null 2>&1
}

__is_fish() {
  __is_shell "$(brew --prefix)/bin/fish"
}

__is_fisher_installed() {
  fish -c 'fisher --version' > /dev/null 2>&1
}

__is_macos() {
  [ "$(uname -s)" = 'Darwin' ]
}

__is_shell() {
  [ "${1-}" = "$SHELL" ]
}

__is_ssh_configured() {
  [ -f "$DOTFILES_SSH_KEY" ]
}

__is_tty() {
  [ -t 0 ] && [ -t 1 ]
}

__is_vim_plug_installed() {
  [ -f "$HOME/.vim/autoload/plug.vim" ]
}

__mkdir() {
  __ mkdir -p "$1"
  __chmod "$1"
}

__pager() {
  if [ -n "${PAGER-}" ]; then
    sh -c "$PAGER"
  elif __is_callable less; then
    less "${LESS-}"
  else
    cat
  fi
}

__print_command() {
  __print_info "\$ $(__quote_params "$@")"
}

__print_confirmation() {
  __print_info "✓ $*"
}

__print_error() {
  __printf '\033[0;31m× %s\033[0m\n' "$*" >&2
}

__print_error_and_exit() {
  __print_error "$*"
  exit 1
}

__print_heading() {
  __printf '\n\033[1;33m· %s\033[0m\n' "$*"
}

__print_heading_dimmed() {
  __printf '\n\033[1;2m· %s\033[0m\n' "$*"
}

__print_info() {
  __printf '\033[2m%s\033[0m\n' "$*"
}

__print_info_and_exit() {
  __print_info "$*"
  exit 0
}

__print_success() {
  __printf '\033[0;32m✓ %s\033[0m\n' "$*"
}

__print_warning() {
  __printf '\033[1m▴ %s\033[0m\n' "$*"
}

__printf() {
  if [ $# -eq 0 ]; then
    printf ''
    return 0
  fi

  format="${1-}"
  shift

  if [ -n "$format" ]; then
    # shellcheck disable=SC2059
    printf "$format" "$(__string_replace "$HOME" '~' "$*")"
  fi
}

__quote_params() {
  python3 -c '
import shlex, sys
params = (shlex.quote(param) for param in sys.argv[1:])
sys.stdout.write(" ".join(params))' "$@"
}

__ssh_add() {
  __print_command 'ssh-add' "$@"
  ssh-add "$@" > /dev/null 2>&1 || __print_error '`ssh-add` failed'
}

__string_contains() {
  if printf '%s' "$2" | grep -F -q -- "$1"; then
    return 0
  else
    return 1
  fi
}

__string_replace() {
  if [ $# -ne 3 ]; then
    __print_error_and_exit '`__string_replace` requires three arguments'
  fi

  if [ -z "$1" ]; then
    __print_error_and_exit '`__string_replace` pattern can’t be empty'
  fi

  if ! __string_contains "$1" "$3"; then
    echo "$3"
    return 0
  fi

  python3 -c '
import re, sys
pattern, replacement, subject = sys.argv[1:4]
sys.stdout.write(re.sub(pattern, replacement, subject))' "$@"
}

__symlink() {
  parent="$(dirname "$2")"

  if [ -d "$parent" ]; then
    rm -rf "$2"
  else
    __mkdir "$parent"
  fi

  __ ln -s "$1" "$2"
}

__touch() {
  parent="$(dirname "$1")"
  [ -d "$parent" ] || __mkdir "$parent"

  __ touch "$1"
  __chmod "$1"
}

brew() {
  if __is_callable brew; then
    command brew "$@"
  else
    command='/opt/homebrew/bin/brew'
    [ -x "$command" ] || __print_error_and_exit '`brew` is missing'

    command "$command" "$@"
  fi
}
